
package org.scala

import org.apache.spark.SparkConf
import org.apache.spark.storage.StorageLevel
import org.apache.spark.streaming.{Seconds, StreamingContext}
import scala.collection.mutable.ArrayBuffer
import org.apache.spark.streaming.dstream.DStream
import org.apache.spark.SparkContext

/**
 * Counts words in UTF8 encoded, '\n' delimited text received from the network every second.
 *
 * Usage: OffensiveWordCount <hostname> <port>
 * <hostname> and <port> describe the TCP server that Spark Streaming would connect to receive data.
 *
 * To run this on your local machine, you need to first run a Netcat server
 *    `$ nc -lk 9999`
 */
object OffensiveWordCount {
  //ArrayBuffer to store list of offensive words in memory
  val wordList: ArrayBuffer[String] = ArrayBuffer.empty[String];
  
  
  def main(args: Array[String]) {
    if (args.length < 2) {
      System.err.println("Usage: OffensiveWordCount <hostname> <port>")
      System.exit(1)
    }
    
    StreamingExamples.setStreamingLogLevels()

    // Create the context with a 60 second batch size
    val sparkConf = new SparkConf().setAppName("OffensiveWordCount")
    val ssc = new StreamingContext(sparkConf, Seconds(60))
    
    
    //Creating text file stream to store offensive words. 
    //It will monitor HDFS directory /offensiveWords 
    val offensiveLines = ssc.textFileStream("hdfs://localhost:9000/offensiveWords/");
    val lines = ssc.socketTextStream(args(0), args(1).toInt, StorageLevel.MEMORY_AND_DISK_SER);
    
    
    // Create a socket stream on target ip:port and count the
    // words in input stream of \n delimited text (eg. generated by 'nc')
    // Note that no duplication in storage level only for running locally.
    // Replication necessary in distributed scenario for fault tolerance.
    
    //getting offensive words from file  
    val offensiveWordCount = offensiveLines.flatMap(line => line.split(" ")).map(word => (word, 1)).reduceByKey(_ + _);
    //storing offensive words in ArrayBuffer
    offensiveWordCount.foreachRDD(a => { a.foreach(f => {wordList += f._1})});
   
    //Getting all word count of all words entered by user
    val wordCount = lines.flatMap(line => line.split(" ")).map(word => (word, 1)).reduceByKey(_ + _);
        
    //Getting word count of offensive words only
    val offensiveWordsRDD = wordCount.filter {x => matchWord(x._1)%2==1 };
    offensiveWordsRDD.print();
      
    ssc.start()
    ssc.awaitTermination()
 }
  
  /**
   * Filter Method for offensive words    
   */
  def matchWord(ln : String): Double={
    val lineWords = ln.trim.toLowerCase();
    var num: Double = 0;
    
      for(y<-wordList)
       {
         if(y.toLowerCase() == lineWords)
         {
           num = 1;
           return num;
         }
         
       }
    
   return num;
  }
     
}
